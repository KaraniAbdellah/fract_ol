// create a simple program using pthread --> [Done]
// create a simple program using miniLibX
// create a simple program using miniLibX & pthread

/** make a simple fractls **/





void *julia_fractl(void *mlx, void *win_ptr, void *image, int *data, int size_line, int bpp, int endian) {

	// Loop over the screen
	/*
		size_line = 5440 = 1360 * 4
			each pixel present by 4 byte (red, green, blue, alpha)
	*/
	printf("size_line = %d\n", size_line);
	for (int x = 0; x < HEIGHT; x++) {
		for (int y = 0; y < WIDTH; y++) {
            
			// Find pixel position on complex plane
			double zx = 1.5 * (x - WIDTH / 2) / (0.5 * WIDTH);
            double zy = (y - HEIGHT / 2) / (0.5 * HEIGHT);

 			/*
 				Zn^2 + C (C = cRe + cIm * i)
 				For more julia set version: https://en.wikipedia.org/wiki/Julia_set
 					 c = 0.285 + 0i
 					 c = 0.285 + 0.01i
 					 c = −0.835 − 0.2321i
 					 c = −0.8 + 0.156i
 					 c = 0.4 + 0.4i 
 			*/
        	float cRe = 0.4, cIm = 0.4;
            
			// Julia iteration
        	int maxIterations = 100;
        	int iteration = 0;
            
            /*
            	zx: real part of of Zn
            	zy: imaginary part of Zn
            	zx * zx + zy * zy < 16:
            		it is depend you
            */
			while (zx * zx + zy * zy < 16 && iteration < maxIterations) {
		        double tmp = zx * zx - zy * zy + cRe;
		        zy = 2 * zx * zy + cIm;
		        zx = tmp;
		        iteration++;
        	}

			/*
				if (iteration == maxIterations):
					point is part of julia set
				else:
					point outside the julia set
			*/
			if (iteration == maxIterations)   {
				data[x * (size_line / 4) + y] = 0x000000;
			} else {
				int green = (iteration * 255 / maxIterations);
    			int color = green << 8; // shift 8 for green color
    			data[x * (size_line / 4) + y] = color;
			}

		}
	}
	return NULL;
}	
